<!doctype
 
html>
 
<html
 
lang="en">
 
<head>
 
  
<meta
 
charset="utf-8"
 
/>
 
  
<title>CPU
 
Scheduler
 
Simulator
 
‚Äî
 
Glass
 
Premium
 
Edition
 
(Pro)</title>
 
  
<meta
 
name="viewport"
 
content="width=device-width,initial-scale=1"
 
/>
 
  
<style>
 
    
/*
 
=====================
 
GLOBAL
 
=====================
 
*/
 
    
*
 
{
 
box-sizing:
 
border-box;
 
font-family:
 
'Inter',
 
system-ui,
 
-apple-system,
 
sans-serif;
 
}
 
    
 
    
body
 
{
 
      
margin:
 
0;
 
      
background:
 
linear-gradient(135deg,
 
#0c0f17
 
0%,
 
#0f1419
 
100%);
 
      
color:
 
#eaf1ff;
 
      
overflow-x:
 
hidden;
 
    
}
 
    
 
    
a
 
{
 
text-decoration:
 
none;
 
color:
 
#60a5fa;
 
transition:
 
color
 
0.3s
 
ease;
 
}
 
    
a:hover
 
{
 
color:
 
#93c5fd;
 
}
 
 
    
/*
 
=====================
 
NAVBAR
 
=====================
 
*/
 
    
nav
 
{
 
      
display:
 
flex;
 
      
justify-content:
 
space-between;
 
      
align-items:
 
center;
 
      
padding:
 
18px
 
32px;
 
      
background:
 
rgba(20,
 
25,
 
40,
 
0.5);
 
      
backdrop-filter:
 
blur(16px);
 
      
border-bottom:
 
1px
 
solid
 
rgba(96,
 
165,
 
250,
 
0.1);
 
      
box-shadow:
 
0
 
8px
 
32px
 
rgba(0,
 
0,
 
0,
 
0.2);
 
      
animation:
 
slideDown
 
0.6s
 
ease;
 
    
}
 
 
    
@keyframes
 
slideDown
 
{
 
      
from
 
{
 
transform:
 
translateY(-20px);
 
opacity:
 
0;
 
}
 
      
to
 
{
 
transform:
 
translateY(0);
 
opacity:
 
1;
 
}
 
    
}
 
    
 
    
nav
 
.title
 
{
 
      
font-size:
 
22px;
 
      
font-weight:
 
700;
 
      
background:
 
linear-gradient(90deg,
 
#a5b4fc,
 
#60a5fa);
 
      
-webkit-background-clip:
 
text;
 
      
-webkit-text-fill-color:
 
transparent;
 
      
background-clip:
 
text;
 
      
letter-spacing:
 
-0.5px;
 
    
}
 
    
 
    
nav
 
.links
 
{
 
display:
 
flex;
 
gap:
 
28px;
 
}
 
    
nav
 
.links
 
a
 
{
 
      
font-size:
 
14px;
 
      
font-weight:
 
500;
 
      
position:
 
relative;
 
      
padding:
 
8px
 
0;
 
    
}
 
    
nav
 
.links
 
a::after
 
{
 
      
content:
 
'';
 
      
position:
 
absolute;
 
      
bottom:
 
-2px;
 
      
left:
 
0;
 
      
width:
 
0;
 
      
height:
 
2px;
 
      
background:
 
linear-gradient(90deg,
 
#60a5fa,
 
#a5b4fc);
 
      
transition:
 
width
 
0.3s
 
ease;
 
    
}
 
    
nav
 
.links
 
a:hover::after
 
{
 
width:
 
100%;
 
}
 
 
    
/*
 
=====================
 
MAIN
 
LAYOUT
 
=====================
 
*/
 
    
.container
 
{
 
      
display:
 
grid;
 
      
grid-template-columns:
 
380px
 
1fr;
 
      
gap:
 
24px;
 
      
padding:
 
28px;
 
      
animation:
 
fadeIn
 
0.8s
 
ease
 
0.2s
 
both;
 
    
}
 
 
    
@keyframes
 
fadeIn
 
{
 
      
from
 
{
 
opacity:
 
0;
 
transform:
 
translateY(10px);
 
}
 
      
to
 
{
 
opacity:
 
1;
 
transform:
 
translateY(0);
 
}
 
    
}
 
    
 
    
.card
 
{
 
      
background:
 
rgba(20,
 
25,
 
40,
 
0.4);
 
      
backdrop-filter:
 
blur(20px);
 
      
border-radius:
 
20px;
 
      
padding:
 
24px;
 
      
border:
 
1px
 
solid
 
rgba(96,
 
165,
 
250,
 
0.15);
 
      
box-shadow:
 
0
 
8px
 
32px
 
rgba(0,
 
0,
 
0,
 
0.3);
 
      
transition:
 
all
 
0.4s
 
cubic-bezier(0.4,
 
0,
 
0.2,
 
1);
 
      
position:
 
relative;
 
      
overflow:
 
hidden;
 
    
}
 
 
    
.card::before
 
{
 
      
content:
 
'';
 
      
position:
 
absolute;
 
      
top:
 
-50%;
 
      
right:
 
-50%;
 
      
width:
 
300px;
 
      
height:
 
300px;
 
      
background:
 
radial-gradient(circle,
 
rgba(96,
 
165,
 
250,
 
0.1)
 
0%,
 
transparent
 
70%);
 
      
transition:
 
all
 
0.6s
 
ease;
 
      
opacity:
 
0;
 
    
}
 
 
    
.card:hover
 
{
 
      
border-color:
 
rgba(96,
 
165,
 
250,
 
0.3);
 
      
box-shadow:
 
0
 
16px
 
48px
 
rgba(96,
 
165,
 
250,
 
0.15);
 
      
transform:
 
translateY(-4px);
 
    
}
 
 
    
.card:hover::before
 
{
 
      
opacity:
 
1;
 
      
right:
 
-30%;
 
      
top:
 
-30%;
 
    
}
 
 
    
.card
 
h2,
 
.card
 
h3
 
{
 
      
margin-top:
 
0;
 
      
color:
 
#93c5fd;
 
      
font-weight:
 
600;
 
      
font-size:
 
18px;
 
      
letter-spacing:
 
-0.3px;
 
    
}
 
 
    
/*
 
=====================
 
INPUTS
 
=====================
 
*/
 
    
label
 
{
 
      
display:
 
block;
 
      
font-size:
 
12px;
 
      
font-weight:
 
600;
 
      
color:
 
#a5b4fc;
 
      
text-transform:
 
uppercase;
 
      
letter-spacing:
 
0.8px;
 
      
margin:
 
12px
 
0
 
6px
 
0;
 
    
}
 
    
 
    
input,
 
select
 
{
 
      
width:
 
100%;
 
      
padding:
 
12px;
 
      
margin:
 
4px
 
0
 
10px
 
0;
 
      
background:
 
rgba(10,
 
12,
 
20,
 
0.6);
 
      
color:
 
#dbeafe;
 
      
border:
 
1.5px
 
solid
 
rgba(96,
 
165,
 
250,
 
0.2);
 
      
border-radius:
 
12px;
 
      
font-size:
 
14px;
 
      
font-family:
 
'Inter',
 
system-ui;
 
      
transition:
 
all
 
0.3s
 
ease;
 
      
outline:
 
none;
 
    
}
 
 
    
input:hover,
 
select:hover
 
{
 
      
border-color:
 
rgba(96,
 
165,
 
250,
 
0.4);
 
      
background:
 
rgba(10,
 
12,
 
20,
 
0.8);
 
    
}
 
 
    
input:focus,
 
select:focus
 
{
 
      
border-color:
 
#60a5fa;
 
      
background:
 
rgba(10,
 
12,
 
20,
 
0.95);
 
      
box-shadow:
 
0
 
0
 
0
 
3px
 
rgba(96,
 
165,
 
250,
 
0.1);
 
      
transform:
 
translateY(-1px);
 
    
}
 
 
    
input::placeholder
 
{
 
      
color:
 
#64748b;
 
    
}
 
 
    
/*
 
=====================
 
BUTTONS
 
=====================
 
*/
 
    
button
 
{
 
      
padding:
 
11px
 
18px;
 
      
border-radius:
 
12px;
 
      
border:
 
none;
 
      
font-family:
 
'Inter',
 
system-ui;
 
      
font-weight:
 
700;
 
      
cursor:
 
pointer;
 
      
transition:
 
all
 
0.25s
 
cubic-bezier(0.4,
 
0,
 
0.2,
 
1);
 
      
font-size:
 
14px;
 
      
position:
 
relative;
 
      
overflow:
 
hidden;
 
      
text-transform:
 
uppercase;
 
      
letter-spacing:
 
0.5px;
 
    
}
 
 
    
button::before
 
{
 
      
content:
 
'';
 
      
position:
 
absolute;
 
      
top:
 
50%;
 
      
left:
 
50%;
 
      
width:
 
0;
 
      
height:
 
0;
 
      
border-radius:
 
50%;
 
      
background:
 
rgba(255,
 
255,
 
255,
 
0.2);
 
      
transform:
 
translate(-50%,
 
-50%);
 
      
transition:
 
width
 
0.6s,
 
height
 
0.6s;
 
    
}
 
 
    
button:active::before
 
{
 
      
width:
 
300px;
 
      
height:
 
300px;
 
    
}
 
 
    
button:active
 
{
 
      
transform:
 
scale(0.96);
 
    
}
 
 
    
#addProc,
 
#startSim,
 
#startCompare
 
{
 
      
background:
 
linear-gradient(135deg,
 
#2563eb,
 
#1d4ed8);
 
      
color:
 
white;
 
      
width:
 
100%;
 
      
box-shadow:
 
0
 
8px
 
16px
 
rgba(37,
 
99,
 
235,
 
0.3);
 
    
}
 
 
    
#addProc:hover,
 
#startSim:hover,
 
#startCompare:hover
 
{
 
      
background:
 
linear-gradient(135deg,
 
#3b82f6,
 
#2563eb);
 
      
box-shadow:
 
0
 
12px
 
24px
 
rgba(59,
 
130,
 
246,
 
0.4);
 
      
transform:
 
translateY(-2px);
 
    
}
 
 
    
#addProc:disabled,
 
#startSim:disabled,
 
#startCompare:disabled
 
{
 
      
opacity:
 
0.5;
 
      
cursor:
 
not-allowed;
 
      
transform:
 
none;
 
    
}
 
 
    
.btn-ghost
 
{
 
      
background:
 
transparent;
 
      
border:
 
1.5px
 
solid
 
rgba(96,
 
165,
 
250,
 
0.3);
 
      
color:
 
#93c5fd;
 
      
transition:
 
all
 
0.3s
 
ease;
 
    
}
 
 
    
.btn-ghost:hover
 
{
 
      
background:
 
rgba(96,
 
165,
 
250,
 
0.1);
 
      
border-color:
 
rgba(96,
 
165,
 
250,
 
0.6);
 
      
color:
 
#c7d2fe;
 
    
}
 
 
    
.btn-danger
 
{
 
      
background:
 
linear-gradient(135deg,
 
#dc2626,
 
#b91c1c);
 
      
color:
 
white;
 
    
}
 
 
    
.btn-danger:hover
 
{
 
      
background:
 
linear-gradient(135deg,
 
#ef4444,
 
#dc2626);
 
      
box-shadow:
 
0
 
12px
 
24px
 
rgba(239,
 
68,
 
68,
 
0.3);
 
      
transform:
 
translateY(-2px);
 
    
}
 
 
    
.small
 
{
 
      
font-size:
 
12px;
 
      
color:
 
#9fb5ff;
 
      
opacity:
 
0.9;
 
    
}
 
 
    
/*
 
=====================
 
TABLES
 
&
 
WRAPPERS
 
=====================
 
*/
 
    
.table-wrapper
 
{
 
      
border-radius:
 
14px;
 
      
overflow:
 
hidden;
 
      
background:
 
rgba(10,
 
12,
 
20,
 
0.3);
 
      
border:
 
1px
 
solid
 
rgba(96,
 
165,
 
250,
 
0.1);
 
      
transition:
 
all
 
0.3s
 
ease;
 
    
}
 
 
    
.table-wrapper:hover
 
{
 
      
border-color:
 
rgba(96,
 
165,
 
250,
 
0.3);
 
      
box-shadow:
 
inset
 
0
 
0
 
20px
 
rgba(96,
 
165,
 
250,
 
0.05);
 
    
}
 
 
    
table
 
{
 
      
width:
 
100%;
 
      
border-collapse:
 
collapse;
 
      
margin:
 
0;
 
      
font-size:
 
13px;
 
    
}
 
 
    
th,
 
td
 
{
 
      
padding:
 
10px
 
8px;
 
      
border-bottom:
 
1px
 
solid
 
rgba(96,
 
165,
 
250,
 
0.08);
 
      
text-align:
 
left;
 
    
}
 
 
    
th
 
{
 
      
color:
 
#60a5fa;
 
      
font-weight:
 
700;
 
      
background:
 
rgba(96,
 
165,
 
250,
 
0.05);
 
    
}
 
 
    
tr
 
{
 
      
transition:
 
all
 
0.2s
 
ease;
 
    
}
 
 
    
tbody
 
tr:hover
 
{
 
      
background:
 
rgba(96,
 
165,
 
250,
 
0.08);
 
      
transform:
 
scale(1.01);
 
    
}
 
 
    
/*
 
=====================
 
GANTT
 
&
 
TIMELINE
 
=====================
 
*/
 
    
.timeline
 
{
 
      
background:
 
rgba(10,
 
12,
 
20,
 
0.3);
 
      
border:
 
1px
 
solid
 
rgba(96,
 
165,
 
250,
 
0.1);
 
      
border-radius:
 
16px;
 
      
padding:
 
16px;
 
      
margin-top:
 
16px;
 
      
position:
 
relative;
 
      
overflow:
 
hidden;
 
      
min-height:
 
140px;
 
      
animation:
 
timelineSlideIn
 
0.6s
 
ease;
 
    
}
 
 
    
@keyframes
 
timelineSlideIn
 
{
 
      
from
 
{
 
opacity:
 
0;
 
height:
 
0;
 
}
 
      
to
 
{
 
opacity:
 
1;
 
height:
 
auto;
 
}
 
    
}
 
 
    
.gantt-container
 
{
 
      
display:
 
flex;
 
      
gap:
 
20px;
 
    
}
 
 
    
.gantt-column
 
{
 
      
flex:
 
1;
 
      
min-width:
 
0;
 
      
animation:
 
columnFadeIn
 
0.5s
 
ease;
 
    
}
 
 
    
@keyframes
 
columnFadeIn
 
{
 
      
from
 
{
 
opacity:
 
0;
 
transform:
 
translateX(-10px);
 
}
 
      
to
 
{
 
opacity:
 
1;
 
transform:
 
translateX(0);
 
}
 
    
}
 
 
    
.gantt-title
 
{
 
      
font-weight:
 
700;
 
      
margin-bottom:
 
12px;
 
      
color:
 
#93c5fd;
 
      
font-size:
 
14px;
 
    
}
 
 
    
.gantt-row
 
{
 
      
margin-bottom:
 
14px;
 
      
display:
 
flex;
 
      
gap:
 
12px;
 
      
align-items:
 
center;
 
    
}
 
 
    
.gantt-track
 
{
 
      
flex:
 
1;
 
      
height:
 
36px;
 
      
background:
 
rgba(5,
 
8,
 
15,
 
0.6);
 
      
border-radius:
 
10px;
 
      
position:
 
relative;
 
      
overflow:
 
hidden;
 
      
box-shadow:
 
inset
 
0
 
4px
 
12px
 
rgba(0,
 
0,
 
0,
 
0.4);
 
      
border:
 
1px
 
solid
 
rgba(96,
 
165,
 
250,
 
0.1);
 
    
}
 
 
    
.gantt-bar
 
{
 
      
position:
 
absolute;
 
      
height:
 
88%;
 
      
top:
 
6%;
 
      
border-radius:
 
8px;
 
      
display:
 
flex;
 
      
align-items:
 
center;
 
      
justify-content:
 
center;
 
      
color:
 
#041026;
 
      
font-weight:
 
800;
 
      
font-size:
 
12px;
 
      
transition:
 
all
 
0.2s
 
ease;
 
      
cursor:
 
pointer;
 
      
box-shadow:
 
0
 
4px
 
12px
 
rgba(0,
 
0,
 
0,
 
0.3);
 
    
}
 
 
    
.gantt-bar:hover
 
{
 
      
transform:
 
translateY(-6px)
 
scale(1.08);
 
      
box-shadow:
 
0
 
12px
 
28px
 
rgba(0,
 
0,
 
0,
 
0.5);
 
      
filter:
 
brightness(1.1);
 
    
}
 
 
    
.gantt-bar.playing
 
{
 
      
animation:
 
barPulse
 
0.8s
 
ease-in-out
 
infinite;
 
    
}
 
 
    
@keyframes
 
barPulse
 
{
 
      
0%,
 
100%
 
{
 
transform:
 
scale(1)
 
translateY(0);
 
}
 
      
50%
 
{
 
transform:
 
scale(1.08)
 
translateY(-4px);
 
}
 
    
}
 
 
    
.playhead
 
{
 
      
position:
 
absolute;
 
      
width:
 
4px;
 
      
background:
 
linear-gradient(180deg,
 
#7dd3fc
 
0%,
 
#60a5fa
 
100%);
 
      
top:
 
6px;
 
      
bottom:
 
6px;
 
      
border-radius:
 
2px;
 
      
box-shadow:
 
0
 
0
 
20px
 
rgba(96,
 
165,
 
250,
 
0.6),
 
inset
 
0
 
0
 
8px
 
rgba(255,
 
255,
 
255,
 
0.3);
 
      
animation:
 
playheadGlow
 
1.5s
 
ease-in-out
 
infinite;
 
    
}
 
 
    
@keyframes
 
playheadGlow
 
{
 
      
0%,
 
100%
 
{
 
box-shadow:
 
0
 
0
 
20px
 
rgba(96,
 
165,
 
250,
 
0.6),
 
inset
 
0
 
0
 
8px
 
rgba(255,
 
255,
 
255,
 
0.3);
 
}
 
      
50%
 
{
 
box-shadow:
 
0
 
0
 
30px
 
rgba(96,
 
165,
 
250,
 
0.9),
 
inset
 
0
 
0
 
12px
 
rgba(255,
 
255,
 
255,
 
0.5);
 
}
 
    
}
 
 
    
.unroll
 
{
 
      
animation:
 
unrollIn
 
0.7s
 
cubic-bezier(0.34,
 
1.56,
 
0.64,
 
1);
 
    
}
 
 
    
@keyframes
 
unrollIn
 
{
 
      
0%
 
{
 
opacity:
 
0;
 
transform:
 
scaleY(0)
 
rotateX(-80deg);
 
}
 
      
100%
 
{
 
opacity:
 
1;
 
transform:
 
scaleY(1)
 
rotateX(0);
 
}
 
    
}
 
 
    
/*
 
=====================
 
TOOLTIP
 
=====================
 
*/
 
    
.tooltip-card
 
{
 
      
position:
 
fixed;
 
      
pointer-events:
 
none;
 
      
z-index:
 
9999;
 
      
background:
 
rgba(2,
 
6,
 
23,
 
0.95);
 
      
border:
 
1.5px
 
solid
 
rgba(96,
 
165,
 
250,
 
0.3);
 
      
padding:
 
12px
 
14px;
 
      
border-radius:
 
12px;
 
      
color:
 
#dbeafe;
 
      
min-width:
 
180px;
 
      
box-shadow:
 
0
 
16px
 
40px
 
rgba(0,
 
0,
 
0,
 
0.6);
 
      
transition:
 
all
 
0.15s
 
ease;
 
      
opacity:
 
0;
 
      
transform:
 
translateY(8px)
 
scale(0.95);
 
      
backdrop-filter:
 
blur(16px);
 
    
}
 
 
    
.tooltip-card.show
 
{
 
      
opacity:
 
1;
 
      
transform:
 
translateY(0)
 
scale(1);
 
    
}
 
 
    
.tooltip-row
 
{
 
      
display:
 
flex;
 
      
justify-content:
 
space-between;
 
      
font-size:
 
12px;
 
      
margin-top:
 
6px;
 
      
gap:
 
12px;
 
    
}
 
 
    
.progress-mini
 
{
 
      
height:
 
6px;
 
      
background:
 
rgba(96,
 
165,
 
250,
 
0.1);
 
      
border-radius:
 
6px;
 
      
margin-top:
 
8px;
 
      
overflow:
 
hidden;
 
    
}
 
 
    
.progress-mini>
 
i
 
{
 
      
display:
 
block;
 
      
height:
 
100%;
 
      
background:
 
linear-gradient(90deg,
 
#7c3aed,
 
#60a5fa);
 
      
width:
 
0;
 
      
transition:
 
width
 
0.3s
 
ease;
 
    
}
 
 
    
/*
 
=====================
 
AI
 
MODAL
 
=====================
 
*/
 
    
#aiModal
 
{
 
      
position:
 
fixed;
 
      
inset:
 
0;
 
      
background:
 
rgba(0,
 
0,
 
0,
 
0.7);
 
      
display:
 
none;
 
      
align-items:
 
center;
 
      
justify-content:
 
center;
 
      
animation:
 
modalBackdropIn
 
0.3s
 
ease;
 
      
backdrop-filter:
 
blur(4px);
 
    
}
 
 
    
@keyframes
 
modalBackdropIn
 
{
 
      
from
 
{
 
opacity:
 
0;
 
}
 
      
to
 
{
 
opacity:
 
1;
 
}
 
    
}
 
 
    
#aiBox
 
{
 
      
background:
 
linear-gradient(135deg,
 
rgba(20,
 
25,
 
40,
 
0.95)
 
0%,
 
rgba(15,
 
20,
 
35,
 
0.95)
 
100%);
 
      
backdrop-filter:
 
blur(20px);
 
      
padding:
 
24px;
 
      
border-radius:
 
18px;
 
      
width:
 
95%;
 
      
max-width:
 
540px;
 
      
border:
 
1px
 
solid
 
rgba(96,
 
165,
 
250,
 
0.2);
 
      
box-shadow:
 
0
 
20px
 
60px
 
rgba(0,
 
0,
 
0,
 
0.6);
 
      
animation:
 
modalSlideIn
 
0.4s
 
cubic-bezier(0.34,
 
1.56,
 
0.64,
 
1);
 
    
}
 
 
    
@keyframes
 
modalSlideIn
 
{
 
      
from
 
{
 
opacity:
 
0;
 
transform:
 
translateY(-30px)
 
scale(0.95);
 
}
 
      
to
 
{
 
opacity:
 
1;
 
transform:
 
translateY(0)
 
scale(1);
 
}
 
    
}
 
 
    
#aiBox
 
h3
 
{
 
      
color:
 
#93c5fd;
 
      
margin-top:
 
0;
 
    
}
 
 
    
#aiQuery
 
{
 
      
width:
 
100%;
 
      
height:
 
100px;
 
      
background:
 
rgba(5,
 
8,
 
15,
 
0.6);
 
      
color:
 
#dbeafe;
 
      
border-radius:
 
12px;
 
      
padding:
 
12px;
 
      
border:
 
1.5px
 
solid
 
rgba(96,
 
165,
 
250,
 
0.2);
 
      
font-family:
 
'Inter',
 
system-ui;
 
      
font-size:
 
14px;
 
      
resize:
 
none;
 
      
transition:
 
all
 
0.3s
 
ease;
 
    
}
 
 
    
#aiQuery:focus
 
{
 
      
border-color:
 
#60a5fa;
 
      
background:
 
rgba(5,
 
8,
 
15,
 
0.9);
 
      
box-shadow:
 
0
 
0
 
0
 
3px
 
rgba(96,
 
165,
 
250,
 
0.1);
 
    
}
 
 
    
#aiAnswer
 
{
 
      
margin-top:
 
14px;
 
      
color:
 
#c7d2fe;
 
      
line-height:
 
1.6;
 
      
animation:
 
fadeInUp
 
0.4s
 
ease;
 
    
}
 
 
    
@keyframes
 
fadeInUp
 
{
 
      
from
 
{
 
opacity:
 
0;
 
transform:
 
translateY(10px);
 
}
 
      
to
 
{
 
opacity:
 
1;
 
transform:
 
translateY(0);
 
}
 
    
}
 
 
    
/*
 
=====================
 
AI
 
HELP
 
BUTTON
 
=====================
 
*/
 
    
#aiHelpBtn
 
{
 
      
position:
 
fixed;
 
      
right:
 
20px;
 
      
bottom:
 
20px;
 
      
padding:
 
14px
 
18px;
 
      
border-radius:
 
14px;
 
      
background:
 
linear-gradient(135deg,
 
#10b981,
 
#059669);
 
      
border:
 
none;
 
      
color:
 
white;
 
      
font-weight:
 
800;
 
      
cursor:
 
pointer;
 
      
box-shadow:
 
0
 
12px
 
36px
 
rgba(16,
 
185,
 
129,
 
0.3);
 
      
transition:
 
all
 
0.3s
 
ease;
 
      
font-size:
 
16px;
 
      
z-index:
 
1000;
 
      
animation:
 
slideInBottom
 
0.5s
 
ease
 
0.3s
 
both;
 
    
}
 
 
    
@keyframes
 
slideInBottom
 
{
 
      
from
 
{
 
opacity:
 
0;
 
transform:
 
translateY(30px);
 
}
 
      
to
 
{
 
opacity:
 
1;
 
transform:
 
translateY(0);
 
}
 
    
}
 
 
    
#aiHelpBtn:hover
 
{
 
      
transform:
 
translateY(-4px)
 
scale(1.08);
 
      
box-shadow:
 
0
 
16px
 
48px
 
rgba(16,
 
185,
 
129,
 
0.5);
 
    
}
 
 
    
#aiHelpBtn:active
 
{
 
      
transform:
 
scale(0.96);
 
    
}
 
 
    
hr
 
{
 
      
border:
 
none;
 
      
border-top:
 
1px
 
solid
 
rgba(96,
 
165,
 
250,
 
0.1);
 
      
margin:
 
16px
 
0;
 
    
}
 
 
    
/*
 
=====================
 
FLEX
 
HELPERS
 
=====================
 
*/
 
    
.button-group
 
{
 
      
display:
 
flex;
 
      
gap:
 
10px;
 
      
flex-wrap:
 
wrap;
 
    
}
 
 
    
.button-group
 
button
 
{
 
      
flex:
 
1;
 
      
min-width:
 
100px;
 
    
}
 
 
    
/*
 
=====================
 
FOOTER
 
=====================
 
*/
 
    
footer
 
{
 
      
text-align:
 
center;
 
      
padding:
 
20px;
 
      
color:
 
#64748b;
 
      
font-size:
 
13px;
 
      
border-top:
 
1px
 
solid
 
rgba(96,
 
165,
 
250,
 
0.05);
 
      
background:
 
rgba(0,
 
0,
 
0,
 
0.2);
 
      
animation:
 
fadeIn
 
0.8s
 
ease
 
0.6s
 
both;
 
    
}
 
 
    
/*
 
=====================
 
RESPONSIVE
 
=====================
 
*/
 
    
@media
 
(max-width:
 
1024px)
 
{
 
      
.container
 
{
 
        
grid-template-columns:
 
1fr;
 
      
}
 
      
.gantt-container
 
{
 
        
flex-direction:
 
column;
 
      
}
 
    
}
 
 
    
@media
 
(max-width:
 
640px)
 
{
 
      
nav
 
{
 
        
flex-direction:
 
column;
 
        
gap:
 
12px;
 
        
padding:
 
12px
 
16px;
 
      
}
 
      
.container
 
{
 
        
padding:
 
16px;
 
        
gap:
 
16px;
 
      
}
 
      
.card
 
{
 
        
padding:
 
16px;
 
      
}
 
      
button
 
{
 
        
padding:
 
10px
 
14px;
 
        
font-size:
 
13px;
 
      
}
 
    
}3
 
  
</style>
 
</head>
 
<body>
 
  
<nav>
 
    
<div
 
class="title">
üöÄ
 
CPU
 
Scheduler
 
‚Äî
 
Pro</div>
 
    
<div
 
class="links">
 
      
<a
 
id="githubLink"
 
href="https://github.com/placeholder"
 
target="_blank">GitHub</a>
 
      
<a
 
id="ytLink"
 
href="https://youtu.be/qOS0j2l3u9Y"
 
target="_blank">YouTube</a>
 
    
</div>
 
  
</nav>
 
 
  
<div
 
class="container">
 
    
<!--
 
LEFT
 
CONTROLS
 
-->
 
    
<div
 
class="card">
 
      
<h2>Process
 
&
 
Controls</h2>
 
 
      
<label>Label</label>
 
      
<input
 
id="procLabel"
 
placeholder="P1
 
(optional)"
 
/>
 
 
      
<label>Arrival
 
Time</label>
 
      
<input
 
id="arrival"
 
type="number"
 
min="0"
 
value="0"
 
/>
 
 
      
<label>Burst
 
Time</label>
 
      
<input
 
id="burst"
 
type="number"
 
min="1"
 
value="4"
 
/>
 
 
      
<label>Priority
 
(lower
 
‚Üí
 
higher)</label>
 
      
<input
 
id="priority"
 
type="number"
 
min="0"
 
value="0"
 
/>
 
 
      
<div
 
class="button-group">
 
        
<button
 
id="addProc">
‚ûï
 
Add</button>
 
        
<button
 
class="btn-ghost"
 
id="clearAll">
üóë
 
Clear</button>
 
      
</div>
 
 
      
<label
 
style="margin-top:
 
16px">Primary
 
Algorithm</label>
 
      
<select
 
id="algorithm">
 
        
<option
 
value="fcfs">FCFS</option>
 
        
<option
 
value="sjf">SJF
 
(non-preemptive)</option>
 
        
<option
 
value="sjf-pre">SJF
 
(preemptive)</option>
 
        
<option
 
value="priority">Priority
 
(non-preemptive)</option>
 
        
<option
 
value="priority-pre">Priority
 
(preemptive)</option>
 
        
<option
 
value="rr">Round
 
Robin</option>
 
      
</select>
 
 
      
<label>Time
 
Quantum
 
(RR)</label>
 
      
<input
 
id="quantum"
 
type="number"
 
value="2"
 
/>
 
 
      
<label>Speed
 
(ms/unit)</label>
 
      
<input
 
id="speed"
 
type="number"
 
value="200"
 
/>
 
 
      
<div
 
class="button-group">
 
        
<button
 
id="startSim">
‚ñ∂
 
Start</button>
 
        
<button
 
class="btn-ghost"
 
id="pauseSim">
‚è∏
 
Pause</button>
 
        
<button
 
class="btn-ghost"
 
id="resetSim">
üîÑ
 
Reset</button>
 
      
</div>
 
 
      
<hr
 
/>
 
 
      
<h3>Comparison
 
Mode</h3>
 
 
      
<label>Secondary
 
Algorithm</label>
 
      
<select
 
id="algorithmB">
 
        
<option
 
value="none">--
 
None
 
--</option>
 
        
<option
 
value="fcfs">FCFS</option>
 
        
<option
 
value="sjf">SJF</option>
 
        
<option
 
value="sjf-pre">SJF
 
(preemptive)</option>
 
        
<option
 
value="priority">Priority</option>
 
        
<option
 
value="priority-pre">Priority
 
(preemptive)</option>
 
        
<option
 
value="rr">Round
 
Robin</option>
 
      
</select>
 
 
      
<div
 
class="button-group">
 
        
<button
 
id="startCompare"
 
class="btn-ghost">
‚öñ
 
Compare</button>
 
      
</div>
 
 
      
<hr
 
/>
 
 
      
<div
 
class="button-group">
 
        
<button
 
id="exportCSV">
üìä
 
CSV</button>
 
        
<button
 
class="btn-ghost"
 
id="exportReport">
üìÑ
 
PDF</button>
 
        
<button
 
class="btn-ghost"
 
id="loadExample">
üìù
 
Example</button>
 
      
</div>
 
 
      
<div
 
style="margin-top:
 
16px;
 
padding:
 
12px;
 
background:
 
rgba(96,
 
165,
 
250,
 
0.05);
 
border-radius:
 
10px;
 
border:
 
1px
 
solid
 
rgba(96,
 
165,
 
250,
 
0.1);">
 
        
<div
 
class="small">Processes:
 
<strong
 
id="procCount">0</strong></div>
 
        
<div
 
class="small"
 
style="margin-top:
 
6px;">Avg
 
WT:
 
<strong
 
id="avgWT">‚Äî</strong>
 
&nbsp;
 
Avg
 
TAT:
 
<strong
 
id="avgTT">‚Äî</strong></div>
 
        
<div
 
class="small"
 
style="margin-top:
 
6px;">CPU
 
Util:
 
<strong
 
id="cpuUtil">‚Äî</strong>
 
&nbsp;
 
Throughput:
 
<strong
 
id="throughput">‚Äî</strong></div>
 
      
</div>
 
    
</div>
 
 
    
<!--
 
RIGHT
 
VISUALS
 
-->
 
    
<div
 
class="card"
 
id="visCard">
 
      
<div
 
style="display:
 
flex;
 
justify-content:
 
space-between;
 
align-items:
 
center;
 
margin-bottom:
 
12px;">
 
        
<div><strong>Gantt
 
Timeline</strong>
 
<span
 
class="small">(hover
 
to
 
focus)</span></div>
 
        
<div
 
class="small"
 
id="readyQ">Ready:
 
‚Äî</div>
 
      
</div>
 
 
      
<div
 
class="timeline
 
unroll"
 
id="timeline"></div>
 
 
      
<div
 
style="margin-top:
 
16px;
 
display:
 
flex;
 
gap:
 
16px;">
 
        
<div
 
style="flex:
 
1;">
 
          
<strong>Per
‚Äë
Process
 
Metrics</strong>
 
          
<div
 
id="metricsTable"
 
class="table-wrapper"></div>
 
        
</div>
 
        
<div
 
style="width:
 
300px;">
 
          
<strong>Input
 
Table</strong>
 
          
<div
 
class="table-wrapper">
 
            
<table
 
id="procTable">
 
              
<thead>
 
                
<tr><th>Label</th><th>AT</th><th>BT</th><th>P</th><th></th></tr>
 
              
</thead>
 
              
<tbody></tbody>
 
            
</table>
 
          
</div>
 
        
</div>
 
      
</div>
 
 
      
<div
 
style="margin-top:
 
16px;">
 
        
<strong>Schedule
 
Output</strong>
 
        
<div
 
id="seqOut"
 
class="small"
 
style="margin-top:
 
8px;
 
padding:
 
10px;
 
background:
 
rgba(96,
 
165,
 
250,
 
0.05);
 
border-radius:
 
8px;
 
border-left:
 
3px
 
solid
 
#60a5fa;">‚Äî</div>
 
      
</div>
 
    
</div>
 
  
</div>
 
 
  
<div
 
id="tooltip"
 
class="tooltip-card"
 
role="tooltip"
 
aria-hidden="true"></div>
 
 
  
<!--
 
AI
 
HELP
 
BUTTON
 
-->
 
  
<button
 
id="aiHelpBtn"
 
title="AI
 
Help">
ü§ñ
 
Help</button>
 
 
  
<!--
 
AI
 
MODAL
 
-->
 
  
<div
 
id="aiModal">
 
    
<div
 
id="aiBox">
 
      
<h3>
üí°
 
AI
 
Assistant</h3>
 
      
<p
 
style="color:
 
#a5b4fc;
 
font-size:
 
13px;">Ask
 
questions
 
about
 
scheduling
 
algorithms
 
and
 
metrics.</p>
 
      
<textarea
 
id="aiQuery"
 
placeholder="e.g.,
 
'Explain
 
SJF'"></textarea>
 
      
<div
 
style="display:
 
flex;
 
gap:
 
10px;
 
margin-top:
 
12px;">
 
        
<button
 
id="aiSend"
 
style="flex:
 
1;">Send</button>
 
        
<button
 
id="aiClose"
 
class="btn-ghost"
 
style="flex:
 
1;">Close</button>
 
      
</div>
 
      
<div
 
id="aiAnswer"></div>
 
    
</div>
 
  
</div>
 
 
  
<footer>Glass
 
Premium
 
‚Äî
 
CPU
 
Scheduler
 
Simulator
 
‚Ä¢
 
2025
 
‚Ä¢
 
Optimized
 
for
 
Performance</footer>
 
 
  
<script>
 
    
//
 
==================
 
STATE
 
==================
 
    
let
 
processes
 
=
 
[];
 
    
let
 
nextId
 
=
 
1;
 
    
let
 
currentSchedule
 
=
 
{
 
seq:
 
[],
 
metrics:
 
{}
 
};
 
    
let
 
compareSchedule
 
=
 
null;
 
 
    
const
 
procTableBody
 
=
 
document.querySelector('#procTable
 
tbody');
 
    
const
 
timeline
 
=
 
document.getElementById('timeline');
 
    
const
 
metricsTableDiv
 
=
 
document.getElementById('metricsTable');
 
    
const
 
readyQ
 
=
 
document.getElementById('readyQ');
 
    
const
 
seqOut
 
=
 
document.getElementById('seqOut');
 
    
const
 
tooltip
 
=
 
document.getElementById('tooltip');
 
 
    
let
 
anim
 
=
 
{
 
      
events:
 
[],
 
      
idx:
 
0,
 
      
scale:
 
200,
 
      
playing:
 
false,
 
      
paused:
 
false,
 
      
playhead:
 
null,
 
      
minStart:
 
0,
 
      
maxEnd:
 
0,
 
      
total:
 
1
 
    
};
 
 
    
//
 
==================
 
COLOR
 
HELPERS
 
==================
 
    
function
 
colorFor(pid)
 
{
 
      
const
 
palette
 
=
 
['#7c3aed',
 
'#60a5fa',
 
'#34d399',
 
'#f97316',
 
'#ef4444',
 
'#f59e0b',
 
'#14b8a6',
 
'#a78bfa'];
 
      
return
 
palette[(pid
 
-
 
1)
 
%
 
palette.length];
 
    
}
 
 
    
function
 
shade(hex,
 
pct)
 
{
 
      
if
 
(!hex
 
||
 
hex[0]
 
!==
 
'#')
 
return
 
hex;
 
      
const
 
f
 
=
 
parseInt(hex.slice(1),
 
16),
 
t
 
=
 
pct
 
<0
 
?
 
0
 
:
 
255,
 
p
 
=
 
Math.abs(pct)
 
/
 
100;
 
      
const
 
R
 
=
 
f>>
 
16,
 
G
 
=
 
f>>
 
8
 
&
 
0x00FF,
 
B
 
=
 
f
 
&
 
0x0000FF;
 
      
const
 
nR
 
=
 
Math.round((t
 
-
 
R)
 
*
 
p)
 
+
 
R,
 
nG
 
=
 
Math.round((t
 
-
 
G)
 
*
 
p)
 
+
 
G,
 
nB
 
=
 
Math.round((t
 
-
 
B)
 
*
 
p)
 
+
 
B;
 
      
return
 
`rgb(${nR},${nG},${nB})`;
 
    
}
 
 
    
//
 
==================
 
RENDER
 
PROCESS
 
TABLE
 
==================
 
    
function
 
renderProcessTable()
 
{
 
      
procTableBody.innerHTML
 
=
 
'';
 
      
processes.sort((a,
 
b)
 
=>
 
a.id
 
-
 
b.id).forEach(p
 
=>
 
{
 
        
const
 
tr
 
=
 
document.createElement('tr');
 
        
tr.innerHTML
 
=
 
`<td>${p.label}</td><td>${p.arrival}</td><td>${p.burst}</td><td>${p.priority}</td><td><button
 
class='delProc'
 
data-id='${p.id}'
 
style='padding:4px
 
8px;font-size:11px;background:#dc2626;color:white;border:none;border-radius:6px;cursor:pointe
r;transition:0.2s;'>Delete</button></td>`;
 
        
procTableBody.appendChild(tr);
 
      
});
 
 
      
document.querySelectorAll('.delProc').forEach(b
 
=>
 
{
 
        
b.addEventListener('click',
 
(e)
 
=>
 
{
 
          
const
 
id
 
=
 
Number(e.target.dataset.id);
 
          
processes
 
=
 
processes.filter(x
 
=>
 
x.id
 
!==
 
id);
 
          
renderProcessTable();
 
        
});
 
        
b.addEventListener('mouseenter',
 
(e)
 
=>
 
{
 
          
e.target.style.background
 
=
 
'#ef4444';
 
          
e.target.style.transform
 
=
 
'scale(1.05)';
 
        
});
 
        
b.addEventListener('mouseleave',
 
(e)
 
=>
 
{
 
          
e.target.style.background
 
=
 
'#dc2626';
 
          
e.target.style.transform
 
=
 
'scale(1)';
 
        
});
 
      
});
 
 
      
document.getElementById('procCount').textContent
 
=
 
processes.length;
 
    
}
 
 
    
//
 
==================
 
ADD
 
/
 
CLEAR
 
/
 
EXAMPLE
 
==================
 
    
document.getElementById('addProc').addEventListener('click',
 
()
 
=>
 
{
 
      
const
 
label
 
=
 
document.getElementById('procLabel').value.trim();
 
      
const
 
arrival
 
=
 
Number(document.getElementById('arrival').value);
 
      
const
 
burst
 
=
 
Number(document.getElementById('burst').value);
 
      
const
 
priority
 
=
 
Number(document.getElementById('priority').value);
 
 
      
if
 
(!Number.isFinite(arrival)
 
||
 
arrival
 
<0
 
||
 
!Number.isFinite(burst)
 
||
 
burst
 
<=
 
0)
 
{
 
        
alert('
‚úã
 
Enter
 
valid
 
Arrival
 
Time
 
(‚â•0)
 
and
 
Burst
 
Time
 
(>0)');
 
        
return;
 
      
}
 
 
      
const
 
id
 
=
 
nextId++;
 
      
processes.push({
 
id,
 
label:
 
label
 
||
 
('P'
 
+
 
id),
 
arrival,
 
burst,
 
priority
 
});
 
      
renderProcessTable();
 
 
      
//
 
Clear
 
inputs
 
      
document.getElementById('procLabel').value
 
=
 
'';
 
      
document.getElementById('arrival').value
 
=
 
'0';
 
      
document.getElementById('burst').value
 
=
 
'4';
 
      
document.getElementById('priority').value
 
=
 
'0';
 
    
});
 
 
    
document.getElementById('clearAll').addEventListener('click',
 
()
 
=>
 
{
 
      
if
 
(confirm('
üóë
 
Clear
 
all
 
processes?'))
 
{
 
        
processes
 
=
 
[];
 
        
nextId
 
=
 
1;
 
        
renderProcessTable();
 
        
resetVisuals();
 
      
}
 
    
});
 
 
    
document.getElementById('loadExample').addEventListener('click',
 
()
 
=>
 
{
 
      
processes
 
=
 
[
 
        
{
 
id:
 
1,
 
label:
 
'P1',
 
arrival:
 
0,
 
burst:
 
5,
 
priority:
 
2
 
},
 
        
{
 
id:
 
2,
 
label:
 
'P2',
 
arrival:
 
2,
 
burst:
 
3,
 
priority:
 
1
 
},
 
        
{
 
id:
 
3,
 
label:
 
'P3',
 
arrival:
 
4,
 
burst:
 
2,
 
priority:
 
3
 
}
 
      
];
 
      
nextId
 
=
 
4;
 
      
renderProcessTable();
 
    
});
 
 
    
//
 
==================
 
CSV
 
&
 
REPORT
 
==================
 
    
function
 
exportCSV()
 
{
 
      
if
 
(!currentSchedule.metrics
 
||
 
Object.keys(currentSchedule.metrics).length
 
===
 
0)
 
{
 
        
alert('
‚ö†
 
Run
 
simulation
 
first');
 
        
return;
 
      
}
 
 
      
const
 
rows
 
=
 
[['Process',
 
'Arrival',
 
'Burst',
 
'Completion',
 
'TAT',
 
'WT']];
 
      
Object.keys(currentSchedule.metrics).map(k
 
=>
 
Number(k)).sort((a,
 
b)
 
=>
 
a
 
-
 
b).forEach(k
 
=>
 
{
 
        
const
 
m
 
=
 
currentSchedule.metrics[k];
 
        
const
 
label
 
=
 
processes.find(p
 
=>
 
p.id
 
===
 
k)?.label
 
||
 
('P'
 
+
 
k);
 
        
rows.push([label,
 
m.arrival,
 
m.burst,
 
m.completion,
 
m.turnaround,
 
m.waiting]);
 
      
});
 
 
      
const
 
csv
 
=
 
rows.map(r
 
=>
 
r.join(',')).join('\n');
 
      
const
 
blob
 
=
 
new
 
Blob([csv],
 
{
 
type:
 
'text/csv'
 
});
 
      
const
 
url
 
=
 
URL.createObjectURL(blob);
 
      
const
 
a
 
=
 
document.createElement('a');
 
      
a.href
 
=
 
url;
 
      
a.download
 
=
 
'scheduler_metrics.csv';
 
      
a.click();
 
      
URL.revokeObjectURL(url);
 
    
}
 
 
    
function
 
exportReportPDF()
 
{
 
      
if
 
(!currentSchedule.metrics
 
||
 
Object.keys(currentSchedule.metrics).length
 
===
 
0)
 
{
 
        
alert('
‚ö†
 
Run
 
simulation
 
first');
 
        
return;
 
      
}
 
 
      
const
 
w
 
=
 
window.open('about:blank',
 
'_blank');
 
      
const
 
doc
 
=
 
w.document;
 
      
let
 
html
 
=
 
`<!doctype
 
html><html><head><meta
 
charset="utf-8"><title>CPU
 
Scheduler
 
Report</title><style>body{font-family:Arial;color:#0b1220;padding:20px;background:#f5f5f5}h1{
color:#1e40af;margin-bottom:20px}table{width:100%;border-collapse:collapse;margin:20px
 
0}th,td{padding:10px;border:1px
 
solid
 
#ddd;text-align:left}th{background:#2563eb;color:white;font-weight:bold}</style></head><body>
<h1>
üìä
 
CPU
 
Scheduler
 
Report</h1><table><tr><th>Process</th><th>Arrival</th><th>Burst</th><th>Completion</th><t
h>TAT</th><th>WT</th></tr>`;
 
 
      
Object.keys(currentSchedule.metrics).map(k
 
=>
 
Number(k)).sort((a,
 
b)
 
=>
 
a
 
-
 
b).forEach(k
 
=>
 
{
 
        
const
 
m
 
=
 
currentSchedule.metrics[k];
 
        
const
 
label
 
=
 
processes.find(p
 
=>
 
p.id
 
===
 
k)?.label
 
||
 
('P'
 
+
 
k);
 
        
html
 
+=
 
`<tr><td>${label}</td><td>${m.arrival}</td><td>${m.burst}</td><td>${m.completion}</td><td>${
m.turnaround}</td><td>${m.waiting}</td></tr>`;
 
      
});
 
 
      
html
 
+=
 
`</table><p><strong>Schedule:</strong>
 
${seqOut.textContent}</p><p><em>Generated
 
by
 
CPU
 
Scheduler
 
Simulator</em></p></body></html>`;
 
      
doc.open();
 
      
doc.write(html);
 
      
doc.close();
 
 
      
setTimeout(()
 
=>
 
w.print(),
 
500);
 
    
}
 
 
    
document.getElementById('exportCSV').addEventListener('click',
 
exportCSV);
 
    
document.getElementById('exportReport').addEventListener('click',
 
exportReportPDF);
 
 
    
//
 
==================
 
SCHEDULING
 
ALGORITHMS
 
==================
 
    
function
 
cloneProcs()
 
{
 
      
return
 
processes.map(p
 
=>
 
({
 
...p,
 
remaining:
 
p.burst
 
}));
 
    
}
 
 
    
function
 
fcfsSchedule()
 
{
 
      
const
 
list
 
=
 
cloneProcs().sort((a,
 
b)
 
=>
 
a.arrival
 
-
 
b.arrival
 
||
 
a.id
 
-
 
b.id);
 
      
let
 
t
 
=
 
0;
 
      
const
 
seq
 
=
 
[];
 
      
const
 
metrics
 
=
 
{};
 
 
      
list.forEach(p
 
=>
 
{
 
        
t
 
=
 
Math.max(t,
 
p.arrival);
 
        
const
 
start
 
=
 
t,
 
end
 
=
 
t
 
+
 
p.burst;
 
        
seq.push({
 
pid:
 
p.id,
 
label:
 
p.label,
 
start,
 
end
 
});
 
        
metrics[p.id]
 
=
 
{
 
arrival:
 
p.arrival,
 
burst:
 
p.burst,
 
completion:
 
end,
 
turnaround:
 
end
 
-
 
p.arrival,
 
waiting:
 
start
 
-
 
p.arrival
 
};
 
        
t
 
=
 
end;
 
      
});
 
 
      
return
 
{
 
seq,
 
metrics
 
};
 
    
}
 
 
    
function
 
sjfNonPreemptive()
 
{
 
      
const
 
remaining
 
=
 
cloneProcs().sort((a,
 
b)
 
=>
 
a.arrival
 
-
 
b.arrival
 
||
 
a.burst
 
-
 
b.burst
 
||
 
a.id
 
-
 
b.id);
 
      
let
 
t
 
=
 
0;
 
      
const
 
seq
 
=
 
[];
 
      
const
 
metrics
 
=
 
{};
 
 
      
while
 
(remaining.length)
 
{
 
        
const
 
avail
 
=
 
remaining.filter(p
 
=>
 
p.arrival
 
<=
 
t);
 
        
if
 
(!avail.length)
 
{
 
          
t
 
=
 
Math.max(t,
 
remaining[0].arrival);
 
          
continue;
 
        
}
 
 
        
avail.sort((a,
 
b)
 
=>
 
a.burst
 
-
 
b.burst
 
||
 
a.arrival
 
-
 
b.arrival);
 
        
const
 
p
 
=
 
avail[0];
 
        
const
 
start
 
=
 
t,
 
end
 
=
 
t
 
+
 
p.burst;
 
        
seq.push({
 
pid:
 
p.id,
 
label:
 
p.label,
 
start,
 
end
 
});
 
        
metrics[p.id]
 
=
 
{
 
arrival:
 
p.arrival,
 
burst:
 
p.burst,
 
completion:
 
end,
 
turnaround:
 
end
 
-
 
p.arrival,
 
waiting:
 
start
 
-
 
p.arrival
 
};
 
        
remaining.splice(remaining.findIndex(x
 
=>
 
x.id
 
===
 
p.id),
 
1);
 
        
t
 
=
 
end;
 
      
}
 
 
      
return
 
{
 
seq,
 
metrics
 
};
 
    
}
 
 
    
function
 
sjfPreemptive()
 
{
 
      
const
 
procs
 
=
 
cloneProcs().sort((a,
 
b)
 
=>
 
a.arrival
 
-
 
b.arrival
 
||
 
a.id
 
-
 
b.id);
 
      
let
 
t
 
=
 
0;
 
      
const
 
seq
 
=
 
[];
 
      
const
 
rem
 
=
 
procs.map(p
 
=>
 
({
 
...p
 
}));
 
      
const
 
finished
 
=
 
new
 
Set();
 
      
let
 
last
 
=
 
null,
 
lastStart
 
=
 
0;
 
 
      
while
 
(finished.size
 
<procs.length)
 
{
 
        
const
 
avail
 
=
 
rem.filter(p
 
=>
 
p.arrival
 
<=
 
t
 
&&
 
p.remaining>
 
0);
 
        
if
 
(!avail.length)
 
{
 
          
t
 
=
 
Math.min(...rem.filter(p
 
=>
 
p.remaining>
 
0).map(x
 
=>
 
x.arrival));
 
          
continue;
 
        
}
 
 
        
avail.sort((a,
 
b)
 
=>
 
a.remaining
 
-
 
b.remaining
 
||
 
a.arrival
 
-
 
b.arrival);
 
        
const
 
cur
 
=
 
avail[0];
 
 
        
if
 
(last
 
!==
 
cur.id)
 
{
 
          
if
 
(last
 
!==
 
null)
 
seq.push({
 
pid:
 
last,
 
start:
 
lastStart,
 
end:
 
t,
 
label:
 
processes.find(x
 
=>
 
x.id
 
===
 
last).label
 
});
 
          
last
 
=
 
cur.id;
 
          
lastStart
 
=
 
t;
 
        
}
 
 
        
cur.remaining--;
 
        
t++;
 
 
        
if
 
(cur.remaining
 
===
 
0)
 
finished.add(cur.id);
 
      
}
 
 
      
if
 
(last
 
!==
 
null)
 
seq.push({
 
pid:
 
last,
 
start:
 
lastStart,
 
end:
 
t,
 
label:
 
processes.find(x
 
=>
 
x.id
 
===
 
last).label
 
});
 
 
      
const
 
metrics
 
=
 
{};
 
      
processes.forEach(p
 
=>
 
{
 
        
const
 
occ
 
=
 
seq.filter(s
 
=>
 
s.pid
 
===
 
p.id);
 
        
const
 
start
 
=
 
occ.length
 
?
 
occ[0].start
 
:
 
p.arrival;
 
        
const
 
end
 
=
 
occ.length
 
?
 
occ[occ.length
 
-
 
1].end
 
:
 
p.arrival;
 
        
metrics[p.id]
 
=
 
{
 
arrival:
 
p.arrival,
 
burst:
 
p.burst,
 
completion:
 
end,
 
turnaround:
 
end
 
-
 
p.arrival,
 
waiting:
 
(end
 
-
 
p.arrival)
 
-
 
p.burst
 
};
 
      
});
 
 
      
return
 
{
 
seq,
 
metrics
 
};
 
    
}
 
 
    
function
 
priorityNonPreemptive()
 
{
 
      
const
 
remaining
 
=
 
cloneProcs().sort((a,
 
b)
 
=>
 
a.arrival
 
-
 
b.arrival
 
||
 
a.priority
 
-
 
b.priority
 
||
 
a.id
 
-
 
b.id);
 
      
let
 
t
 
=
 
0;
 
      
const
 
seq
 
=
 
[];
 
      
const
 
metrics
 
=
 
{};
 
 
      
while
 
(remaining.length)
 
{
 
        
const
 
avail
 
=
 
remaining.filter(p
 
=>
 
p.arrival
 
<=
 
t);
 
        
if
 
(!avail.length)
 
{
 
          
t
 
=
 
Math.max(t,
 
remaining[0].arrival);
 
          
continue;
 
        
}
 
 
        
avail.sort((a,
 
b)
 
=>
 
a.priority
 
-
 
b.priority
 
||
 
a.arrival
 
-
 
b.arrival);
 
        
const
 
p
 
=
 
avail[0];
 
        
const
 
start
 
=
 
t,
 
end
 
=
 
t
 
+
 
p.burst;
 
        
seq.push({
 
pid:
 
p.id,
 
label:
 
p.label,
 
start,
 
end
 
});
 
        
metrics[p.id]
 
=
 
{
 
arrival:
 
p.arrival,
 
burst:
 
p.burst,
 
completion:
 
end,
 
turnaround:
 
end
 
-
 
p.arrival,
 
waiting:
 
start
 
-
 
p.arrival
 
};
 
        
remaining.splice(remaining.findIndex(x
 
=>
 
x.id
 
===
 
p.id),
 
1);
 
        
t
 
=
 
end;
 
      
}
 
 
      
return
 
{
 
seq,
 
metrics
 
};
 
    
}
 
 
    
function
 
priorityPreemptive()
 
{
 
      
const
 
procs
 
=
 
cloneProcs().sort((a,
 
b)
 
=>
 
a.arrival
 
-
 
b.arrival
 
||
 
a.id
 
-
 
b.id);
 
      
let
 
t
 
=
 
0;
 
      
const
 
rem
 
=
 
procs.map(p
 
=>
 
({
 
...p
 
}));
 
      
const
 
seq
 
=
 
[];
 
      
let
 
last
 
=
 
null,
 
lastStart
 
=
 
0;
 
      
const
 
finished
 
=
 
new
 
Set();
 
 
      
while
 
(finished.size
 
<procs.length)
 
{
 
        
const
 
avail
 
=
 
rem.filter(p
 
=>
 
p.arrival
 
<=
 
t
 
&&
 
p.remaining>
 
0);
 
        
if
 
(!avail.length)
 
{
 
          
t
 
=
 
Math.min(...rem.filter(p
 
=>
 
p.remaining>
 
0).map(x
 
=>
 
x.arrival));
 
          
continue;
 
        
}
 
 
        
avail.sort((a,
 
b)
 
=>
 
a.priority
 
-
 
b.priority
 
||
 
a.arrival
 
-
 
b.arrival);
 
        
const
 
cur
 
=
 
avail[0];
 
 
        
if
 
(last
 
!==
 
cur.id)
 
{
 
          
if
 
(last
 
!==
 
null)
 
seq.push({
 
pid:
 
last,
 
start:
 
lastStart,
 
end:
 
t,
 
label:
 
processes.find(x
 
=>
 
x.id
 
===
 
last).label
 
});
 
          
last
 
=
 
cur.id;
 
          
lastStart
 
=
 
t;
 
        
}
 
 
        
cur.remaining--;
 
        
t++;
 
 
        
if
 
(cur.remaining
 
===
 
0)
 
finished.add(cur.id);
 
      
}
 
 
      
if
 
(last
 
!==
 
null)
 
seq.push({
 
pid:
 
last,
 
start:
 
lastStart,
 
end:
 
t,
 
label:
 
processes.find(x
 
=>
 
x.id
 
===
 
last).label
 
});
 
 
      
const
 
metrics
 
=
 
{};
 
      
processes.forEach(p
 
=>
 
{
 
        
const
 
occ
 
=
 
seq.filter(s
 
=>
 
s.pid
 
===
 
p.id);
 
        
const
 
start
 
=
 
occ.length
 
?
 
occ[0].start
 
:
 
p.arrival;
 
        
const
 
end
 
=
 
occ.length
 
?
 
occ[occ.length
 
-
 
1].end
 
:
 
p.arrival;
 
        
metrics[p.id]
 
=
 
{
 
arrival:
 
p.arrival,
 
burst:
 
p.burst,
 
completion:
 
end,
 
turnaround:
 
end
 
-
 
p.arrival,
 
waiting:
 
(end
 
-
 
p.arrival)
 
-
 
p.burst
 
};
 
      
});
 
 
      
return
 
{
 
seq,
 
metrics
 
};
 
    
}
 
 
    
function
 
roundRobinSchedule(q)
 
{
 
      
const
 
procs
 
=
 
cloneProcs().sort((a,
 
b)
 
=>
 
a.arrival
 
-
 
b.arrival
 
||
 
a.id
 
-
 
b.id);
 
      
let
 
t
 
=
 
0;
 
      
const
 
seq
 
=
 
[];
 
      
const
 
rem
 
=
 
procs.map(p
 
=>
 
({
 
...p
 
}));
 
      
const
 
queue
 
=
 
[];
 
      
const
 
queued
 
=
 
new
 
Set();
 
 
      
while
 
(rem.some(p
 
=>
 
p.remaining>
 
0))
 
{
 
        
rem.forEach(p
 
=>
 
{
 
          
if
 
(p.arrival
 
<=
 
t
 
&&
 
p.remaining>
 
0
 
&&
 
!queued.has(p.id))
 
{
 
            
queue.push(p);
 
            
queued.add(p.id);
 
          
}
 
        
});
 
 
        
if
 
(!queue.length)
 
{
 
          
const
 
next
 
=
 
rem.filter(p
 
=>
 
p.remaining>
 
0).reduce((a,
 
b)
 
=>
 
a.arrival
 
<b.arrival
 
?
 
a
 
:
 
b);
 
          
t
 
=
 
Math.max(t,
 
next.arrival);
 
          
rem.forEach(p
 
=>
 
{
 
            
if
 
(p.arrival
 
<=
 
t
 
&&
 
p.remaining>
 
0
 
&&
 
!queued.has(p.id))
 
{
 
              
queue.push(p);
 
              
queued.add(p.id);
 
            
}
 
          
});
 
          
continue;
 
        
}
 
 
        
const
 
cur
 
=
 
queue.shift();
 
        
const
 
exec
 
=
 
Math.min(q,
 
cur.remaining);
 
        
const
 
start
 
=
 
t,
 
end
 
=
 
t
 
+
 
exec;
 
        
seq.push({
 
pid:
 
cur.id,
 
label:
 
cur.label,
 
start,
 
end
 
});
 
        
cur.remaining
 
-=
 
exec;
 
        
t
 
=
 
end;
 
 
        
rem.forEach(p
 
=>
 
{
 
          
if
 
(p.arrival
 
<=
 
t
 
&&
 
p.remaining>
 
0
 
&&
 
!queued.has(p.id))
 
{
 
            
queue.push(p);
 
            
queued.add(p.id);
 
          
}
 
        
});
 
 
        
if
 
(cur.remaining>
 
0)
 
queue.push(cur);
 
      
}
 
 
      
const
 
metrics
 
=
 
{};
 
      
processes.forEach(p
 
=>
 
{
 
        
const
 
occ
 
=
 
seq.filter(s
 
=>
 
s.pid
 
===
 
p.id);
 
        
const
 
start
 
=
 
occ.length
 
?
 
occ[0].start
 
:
 
p.arrival;
 
        
const
 
end
 
=
 
occ.length
 
?
 
occ[occ.length
 
-
 
1].end
 
:
 
p.arrival;
 
        
metrics[p.id]
 
=
 
{
 
arrival:
 
p.arrival,
 
burst:
 
p.burst,
 
completion:
 
end,
 
turnaround:
 
end
 
-
 
p.arrival,
 
waiting:
 
(end
 
-
 
p.arrival)
 
-
 
p.burst
 
};
 
      
});
 
 
      
return
 
{
 
seq,
 
metrics
 
};
 
    
}
 
 
    
function
 
computeScheduleForList(procList,
 
algo,
 
q)
 
{
 
      
const
 
oldProcs
 
=
 
processes;
 
      
const
 
oldNext
 
=
 
nextId;
 
      
processes
 
=
 
procList.map(p
 
=>
 
({
 
...p
 
}));
 
      
nextId
 
=
 
Math.max(1,
 
...processes.map(p
 
=>
 
p.id))
 
+
 
1;
 
 
      
let
 
res;
 
      
if
 
(algo
 
===
 
'fcfs')
 
res
 
=
 
fcfsSchedule();
 
      
else
 
if
 
(algo
 
===
 
'sjf')
 
res
 
=
 
sjfNonPreemptive();
 
      
else
 
if
 
(algo
 
===
 
'sjf-pre')
 
res
 
=
 
sjfPreemptive();
 
      
else
 
if
 
(algo
 
===
 
'priority')
 
res
 
=
 
priorityNonPreemptive();
 
      
else
 
if
 
(algo
 
===
 
'priority-pre')
 
res
 
=
 
priorityPreemptive();
 
      
else
 
if
 
(algo
 
===
 
'rr')
 
res
 
=
 
roundRobinSchedule(q);
 
      
else
 
res
 
=
 
{
 
seq:
 
[],
 
metrics:
 
{}
 
};
 
 
      
processes
 
=
 
oldProcs;
 
      
nextId
 
=
 
oldNext;
 
      
return
 
res;
 
    
}
 
 
    
function
 
computeSchedule()
 
{
 
      
if
 
(!processes.length)
 
return
 
{
 
seq:
 
[],
 
metrics:
 
{}
 
};
 
 
      
const
 
algo
 
=
 
document.getElementById('algorithm').value;
 
      
const
 
q
 
=
 
Number(document.getElementById('quantum').value)
 
||
 
1;
 
 
      
if
 
(algo
 
===
 
'fcfs')
 
return
 
fcfsSchedule();
 
      
if
 
(algo
 
===
 
'sjf')
 
return
 
sjfNonPreemptive();
 
      
if
 
(algo
 
===
 
'sjf-pre')
 
return
 
sjfPreemptive();
 
      
if
 
(algo
 
===
 
'priority')
 
return
 
priorityNonPreemptive();
 
      
if
 
(algo
 
===
 
'priority-pre')
 
return
 
priorityPreemptive();
 
      
if
 
(algo
 
===
 
'rr')
 
return
 
roundRobinSchedule(q);
 
 
      
return
 
{
 
seq:
 
[],
 
metrics:
 
{}
 
};
 
    
}
 
 
    
function
 
flattenSeq(seq)
 
{
 
      
const
 
items
 
=
 
seq.slice().sort((a,
 
b)
 
=>
 
a.start
 
-
 
b.start
 
||
 
a.end
 
-
 
b.end);
 
      
const
 
merged
 
=
 
[];
 
 
      
for
 
(const
 
s
 
of
 
items)
 
{
 
        
if
 
(!merged.length)
 
merged.push({
 
...s
 
});
 
        
else
 
{
 
          
const
 
last
 
=
 
merged[merged.length
 
-
 
1];
 
          
if
 
(last.pid
 
===
 
s.pid
 
&&
 
last.end
 
===
 
s.start)
 
{
 
            
last.end
 
=
 
s.end;
 
          
}
 
else
 
{
 
            
merged.push({
 
...s
 
});
 
          
}
 
        
}
 
      
}
 
 
      
return
 
merged;
 
    
}
 
 
    
//
 
==================
 
RENDER
 
VISUALS
 
==================
 
    
function
 
renderVisuals(schedule,
 
containerEl,
 
prefix)
 
{
 
      
containerEl.innerHTML
 
=
 
'';
 
 
      
if
 
(!schedule.seq.length)
 
{
 
        
containerEl.textContent
 
=
 
'No
 
schedule.';
 
        
return;
 
      
}
 
 
      
const
 
seq
 
=
 
schedule.seq;
 
      
const
 
minStart
 
=
 
Math.min(...seq.map(s
 
=>
 
s.start));
 
      
const
 
maxEnd
 
=
 
Math.max(...seq.map(s
 
=>
 
s.end));
 
      
const
 
total
 
=
 
Math.max(1,
 
maxEnd
 
-
 
minStart);
 
      
const
 
pids
 
=
 
Array.from(new
 
Set(processes.map(p
 
=>
 
p.id))).sort((a,
 
b)
 
=>
 
a
 
-
 
b);
 
 
      
const
 
col
 
=
 
document.createElement('div');
 
      
col.className
 
=
 
'gantt-column';
 
 
      
const
 
title
 
=
 
document.createElement('div');
 
      
title.className
 
=
 
'gantt-title';
 
      
title.textContent
 
=
 
prefix
 
||
 
'Schedule';
 
      
col.appendChild(title);
 
 
      
const
 
inner
 
=
 
document.createElement('div');
 
      
inner.style.display
 
=
 
'flex';
 
      
inner.style.flexDirection
 
=
 
'column';
 
      
inner.style.gap
 
=
 
'8px';
 
 
      
pids.forEach(pid
 
=>
 
{
 
        
const
 
row
 
=
 
document.createElement('div');
 
        
row.className
 
=
 
'gantt-row';
 
 
        
const
 
labelDiv
 
=
 
document.createElement('div');
 
        
labelDiv.style.width
 
=
 
'80px';
 
        
labelDiv.style.fontWeight
 
=
 
'600';
 
        
labelDiv.textContent
 
=
 
processes.find(p
 
=>
 
p.id
 
===
 
pid)?.label
 
||
 
('P'
 
+
 
pid);
 
 
        
const
 
track
 
=
 
document.createElement('div');
 
        
track.className
 
=
 
'gantt-track';
 
 
        
const
 
parts
 
=
 
seq.filter(s
 
=>
 
s.pid
 
===
 
pid);
 
 
        
parts.forEach(part
 
=>
 
{
 
          
const
 
l
 
=
 
((part.start
 
-
 
minStart)
 
/
 
total)
 
*
 
100;
 
          
const
 
w
 
=
 
((part.end
 
-
 
part.start)
 
/
 
total)
 
*
 
100;
 
          
const
 
bar
 
=
 
document.createElement('div');
 
          
bar.className
 
=
 
'gantt-bar';
 
          
bar.style.left
 
=
 
l
 
+
 
'%';
 
          
bar.style.width
 
=
 
w
 
+
 
'%';
 
 
          
const
 
colr
 
=
 
colorFor(pid);
 
          
bar.style.background
 
=
 
`linear-gradient(135deg,
 
${shade(colr,
 
-12)},
 
${colr})`;
 
          
bar.textContent
 
=
 
part.label;
 
 
          
bar.dataset.start
 
=
 
part.start;
 
          
bar.dataset.end
 
=
 
part.end;
 
          
bar.dataset.pid
 
=
 
pid;
 
          
bar.dataset.label
 
=
 
part.label;
 
          
bar.title
 
=
 
`${part.label}
 
[${part.start}-${part.end}]`;
 
 
          
bar.addEventListener('mousemove',
 
onBarHover);
 
          
bar.addEventListener('mouseleave',
 
()
 
=>
 
tooltip.classList.remove('show'));
 
          
bar.addEventListener('click',
 
()
 
=>
 
focusOnPid(pid));
 
 
          
track.appendChild(bar);
 
        
});
 
 
        
row.appendChild(labelDiv);
 
        
row.appendChild(track);
 
        
inner.appendChild(row);
 
      
});
 
 
      
const
 
marker
 
=
 
document.createElement('div');
 
      
marker.style.marginTop
 
=
 
'10px';
 
      
marker.style.fontSize
 
=
 
'12px';
 
      
marker.className
 
=
 
'small';
 
      
marker.textContent
 
=
 
`
‚è±
 
Time
 
${minStart}
 
‚Üí
 
${maxEnd}
 
(span:
 
${total})`;
 
      
inner.appendChild(marker);
 
 
      
col.appendChild(inner);
 
      
containerEl.appendChild(col);
 
 
      
return
 
{
 
minStart,
 
maxEnd,
 
total
 
};
 
    
}
 
 
    
function
 
renderMain(scheduleA,
 
scheduleB
 
=
 
null)
 
{
 
      
timeline.innerHTML
 
=
 
'';
 
 
      
if
 
(!scheduleB)
 
{
 
        
const
 
colEl
 
=
 
document.createElement('div');
 
        
colEl.className
 
=
 
'gantt-column';
 
        
timeline.appendChild(colEl);
 
        
renderVisuals(scheduleA,
 
timeline,
 
'Primary
 
Schedule');
 
 
        
seqOut.textContent
 
=
 
scheduleA.seq.map(s
 
=>
 
`${s.label}[${s.start}-${s.end}]`).join('
 
‚Üí
 
');
 
        
currentSchedule
 
=
 
scheduleA;
 
        
renderMetricsTable(scheduleA.metrics);
 
        
computeGlobalStats(scheduleA.metrics);
 
 
        
visCard.classList.remove('unroll');
 
        
void
 
visCard.offsetWidth;
 
        
visCard.classList.add('unroll');
 
 
        
anim.events
 
=
 
flattenSeq(scheduleA.seq);
 
        
anim.idx
 
=
 
0;
 
        
anim.scale
 
=
 
Number(document.getElementById('speed').value)
 
||
 
200;
 
        
setupPlayhead(
 
          
Math.min(...scheduleA.seq.map(s
 
=>
 
s.start)),
 
          
Math.max(...scheduleA.seq.map(s
 
=>
 
s.end)),
 
          
Math.max(1,
 
Math.max(...scheduleA.seq.map(s
 
=>
 
s.end))
 
-
 
Math.min(...scheduleA.seq.map(s
 
=>
 
s.start)))
 
        
);
 
        
anim.playing
 
=
 
true;
 
        
anim.paused
 
=
 
false;
 
        
runAnimStep();
 
      
}
 
else
 
{
 
        
const
 
container
 
=
 
document.createElement('div');
 
        
container.className
 
=
 
'gantt-container';
 
 
        
const
 
left
 
=
 
document.createElement('div');
 
        
left.className
 
=
 
'gantt-column';
 
        
const
 
right
 
=
 
document.createElement('div');
 
        
right.className
 
=
 
'gantt-column';
 
 
        
renderVisuals(scheduleA,
 
left,
 
'Primary
 
‚Äî
 
'
 
+
 
document.getElementById('algorithm').value);
 
        
renderVisuals(scheduleB,
 
right,
 
'Secondary
 
‚Äî
 
'
 
+
 
document.getElementById('algorithmB').value);
 
 
        
container.appendChild(left);
 
        
container.appendChild(right);
 
        
timeline.appendChild(container);
 
 
        
seqOut.textContent
 
=
 
'
‚öñ
 
Comparison
 
Mode';
 
        
currentSchedule
 
=
 
scheduleA;
 
        
compareSchedule
 
=
 
scheduleB;
 
        
renderMetricsTable(scheduleA.metrics);
 
        
computeGlobalStats(scheduleA.metrics);
 
 
        
anim.events
 
=
 
flattenSeq(scheduleA.seq);
 
        
anim.idx
 
=
 
0;
 
        
anim.scale
 
=
 
Number(document.getElementById('speed').value)
 
||
 
200;
 
        
setupPlayhead(
 
          
Math.min(...scheduleA.seq.map(s
 
=>
 
s.start)),
 
          
Math.max(...scheduleA.seq.map(s
 
=>
 
s.end)),
 
          
Math.max(1,
 
Math.max(...scheduleA.seq.map(s
 
=>
 
s.end))
 
-
 
Math.min(...scheduleA.seq.map(s
 
=>
 
s.start)))
 
        
);
 
        
anim.playing
 
=
 
true;
 
        
anim.paused
 
=
 
false;
 
        
runAnimStep();
 
      
}
 
    
}
 
 
    
//
 
==================
 
TOOLTIP
 
==================
 
    
function
 
onBarHover(e)
 
{
 
      
const
 
bar
 
=
 
e.currentTarget;
 
      
const
 
label
 
=
 
bar.dataset.label;
 
      
const
 
start
 
=
 
Number(bar.dataset.start);
 
      
const
 
end
 
=
 
Number(bar.dataset.end);
 
      
const
 
dur
 
=
 
end
 
-
 
start;
 
 
      
tooltip.innerHTML
 
=
 
`
 
        
<div
 
style='font-weight:
 
700;
 
color:
 
#93c5fd;'>${label}</div>
 
        
<div
 
class='tooltip-row'><span>Start</span><span
 
style='font-weight:600'>${start}</span></div>
 
        
<div
 
class='tooltip-row'><span>End</span><span
 
style='font-weight:600'>${end}</span></div>
 
        
<div
 
class='tooltip-row'><span>Duration</span><span
 
style='font-weight:600'>${dur}</span></div>
 
        
<div
 
class='progress-mini'><i
 
style='width:
 
${Math.max(6,
 
Math.min(100,
 
(dur
 
/
 
Math.max(1,
 
end))
 
*
 
100))}%'></i></div>
 
      
`;
 
 
      
const
 
x
 
=
 
e.clientX
 
+
 
12;
 
      
const
 
y
 
=
 
e.clientY
 
+
 
12;
 
      
tooltip.style.left
 
=
 
x
 
+
 
'px';
 
      
tooltip.style.top
 
=
 
y
 
+
 
'px';
 
      
tooltip.classList.add('show');
 
    
}
 
 
    
//
 
==================
 
METRICS
 
TABLE
 
==================
 
    
function
 
renderMetricsTable(metrics)
 
{
 
      
const
 
keys
 
=
 
Object.keys(metrics).map(k
 
=>
 
Number(k)).sort((a,
 
b)
 
=>
 
a
 
-
 
b);
 
      
let
 
html
 
=
 
'<table><thead><tr><th>Proc</th><th>AT</th><th>BT</th><th>CT</th><th>TAT</th><th>WT</
th></tr></thead><tbody>';
 
 
      
keys.forEach(k
 
=>
 
{
 
        
const
 
m
 
=
 
metrics[k];
 
        
const
 
label
 
=
 
processes.find(p
 
=>
 
p.id
 
===
 
k)?.label
 
||
 
('P'
 
+
 
k);
 
        
html
 
+=
 
`<tr
 
class='metric-row'
 
data-pid='${k}'><td>${label}</td><td>${m.arrival}</td><td>${m.burst}</td><td>${m.completion}</td><td>${m.turnaround}</td><td>${m.waiting}</td></tr>`;
 
      
});
 
 
      
html
 
+=
 
'</tbody></table>';
 
      
metricsTableDiv.innerHTML
 
=
 
html;
 
 
      
Array.from(metricsTableDiv.querySelectorAll('.metric-row')).forEach(r
 
=>
 
{
 
        
r.addEventListener('mouseenter',
 
()
 
=>
 
{
 
          
highlightPid(Number(r.dataset.pid),
 
true);
 
          
r.style.transform
 
=
 
'scale(1.03)';
 
          
r.style.background
 
=
 
'rgba(96,
 
165,
 
250,
 
0.2)';
 
        
});
 
        
r.addEventListener('mouseleave',
 
()
 
=>
 
{
 
          
highlightPid(null,
 
false);
 
          
r.style.transform
 
=
 
'';
 
          
r.style.background
 
=
 
'';
 
        
});
 
      
});
 
    
}
 
 
    
function
 
highlightPid(pid,
 
on)
 
{
 
      
Array.from(timeline.querySelectorAll('.gantt-bar')).forEach(b
 
=>
 
{
 
        
if
 
(!pid)
 
{
 
          
b.style.opacity
 
=
 
'1';
 
          
b.style.transform
 
=
 
'';
 
          
b.style.boxShadow
 
=
 
'';
 
        
}
 
else
 
if
 
(Number(b.dataset.pid)
 
===
 
pid)
 
{
 
          
b.style.opacity
 
=
 
'1';
 
          
b.style.transform
 
=
 
'scale(1.12)';
 
          
b.style.boxShadow
 
=
 
'0
 
18px
 
44px
 
rgba(0,
 
0,
 
0,
 
0.6)';
 
        
}
 
else
 
{
 
          
b.style.opacity
 
=
 
'0.3';
 
        
}
 
      
});
 
    
}
 
 
    
//
 
==================
 
PLAYHEAD
 
==================
 
    
function
 
setupPlayhead(minStart,
 
maxEnd,
 
total)
 
{
 
      
const
 
existing
 
=
 
timeline.querySelector('.playhead');
 
      
if
 
(existing)
 
existing.remove();
 
 
      
const
 
ph
 
=
 
document.createElement('div');
 
      
ph.className
 
=
 
'playhead';
 
      
timeline.appendChild(ph);
 
 
      
anim.playhead
 
=
 
ph;
 
      
anim.minStart
 
=
 
minStart;
 
      
anim.maxEnd
 
=
 
maxEnd;
 
      
anim.total
 
=
 
total;
 
 
      
updatePlayhead(minStart);
 
    
}
 
 
    
function
 
updatePlayhead(simTime)
 
{
 
      
if
 
(!anim.playhead)
 
return;
 
      
const
 
pct
 
=
 
((simTime
 
-
 
anim.minStart)
 
/
 
Math.max(1,
 
anim.total))
 
*
 
100;
 
      
anim.playhead.style.left
 
=
 
Math.min(100,
 
Math.max(0,
 
pct))
 
+
 
'%';
 
    
}
 
 
    
function
 
computeGlobalStats(metrics)
 
{
 
      
const
 
keys
 
=
 
Object.keys(metrics).map(k
 
=>
 
Number(k));
 
      
if
 
(keys.length
 
===
 
0)
 
{
 
        
document.getElementById('avgWT').textContent
 
=
 
'‚Äî';
 
        
document.getElementById('avgTT').textContent
 
=
 
'‚Äî';
 
        
document.getElementById('cpuUtil').textContent
 
=
 
'‚Äî';
 
        
document.getElementById('throughput').textContent
 
=
 
'‚Äî';
 
        
return;
 
      
}
 
 
      
const
 
avgWT
 
=
 
(keys.reduce((sum,
 
k)
 
=>
 
sum
 
+
 
metrics[k].waiting,
 
0)
 
/
 
keys.length).toFixed(2);
 
      
const
 
avgTT
 
=
 
(keys.reduce((sum,
 
k)
 
=>
 
sum
 
+
 
metrics[k].turnaround,
 
0)
 
/
 
keys.length).toFixed(2);
 
      
const
 
maxEnd
 
=
 
Math.max(...Object.values(metrics).map(m
 
=>
 
m.completion));
 
      
const
 
totalBurst
 
=
 
processes.reduce((sum,
 
p)
 
=>
 
sum
 
+
 
p.burst,
 
0);
 
      
const
 
cpuUtil
 
=
 
maxEnd>
 
0
 
?
 
((totalBurst
 
/
 
maxEnd)
 
*
 
100).toFixed(1)
 
:
 
0;
 
      
const
 
throughput
 
=
 
(keys.length
 
/
 
maxEnd).toFixed(3);
 
 
      
document.getElementById('avgWT').textContent
 
=
 
avgWT;
 
      
document.getElementById('avgTT').textContent
 
=
 
avgTT;
 
      
document.getElementById('cpuUtil').textContent
 
=
 
cpuUtil
 
+
 
'%';
 
      
document.getElementById('throughput').textContent
 
=
 
throughput;
 
    
}
 
 
    
function
 
runAnimStep()
 
{
 
      
if
 
(!anim.playing
 
||
 
anim.paused)
 
return;
 
      
if
 
(anim.idx>=
 
anim.events.length)
 
{
 
        
anim.playing
 
=
 
false;
 
        
return;
 
      
}
 
 
      
const
 
ev
 
=
 
anim.events[anim.idx];
 
      
const
 
bars
 
=
 
Array.from(timeline.querySelectorAll('.gantt-bar')).filter(b
 
=>
 
        
Number(b.dataset.start)
 
===
 
ev.start
 
&&
 
Number(b.dataset.end)
 
===
 
ev.end
 
&&
 
Number(b.dataset.pid)
 
===
 
ev.pid
 
      
);
 
 
      
bars.forEach(b
 
=>
 
b.classList.add('playing'));
 
 
      
const
 
ready
 
=
 
processes
 
        
.filter(p
 
=>
 
p.arrival
 
<=
 
ev.start
 
&&
 
(currentSchedule.metrics[p.id]
 
&&
 
currentSchedule.metrics[p.id].completion>
 
ev.start))
 
        
.map(p
 
=>
 
p.label);
 
      
document.getElementById('readyQ').textContent
 
=
 
ready.length
 
?
 
'
üìã
 
'
 
+
 
ready.join(',
 
')
 
:
 
'Ready:
 
‚Äî';
 
 
      
updatePlayhead(ev.start);
 
 
      
const
 
ms
 
=
 
Math.max(60,
 
(ev.end
 
-
 
ev.start)
 
*
 
anim.scale);
 
 
      
setTimeout(()
 
=>
 
{
 
        
bars.forEach(b
 
=>
 
b.classList.remove('playing'));
 
        
anim.idx++;
 
        
updatePlayhead(ev.end);
 
        
runAnimStep();
 
      
},
 
ms);
 
    
}
 
 
    
//
 
==================
 
START
 
/
 
COMPARE
 
/
 
PAUSE
 
/
 
RESET
 
==================
 
    
document.getElementById('startSim').addEventListener('click',
 
()
 
=>
 
{
 
      
if
 
(anim.playing)
 
return;
 
      
if
 
(!processes.length)
 
return
 
alert('
‚ö†
 
Add
 
processes
 
first');
 
 
      
const
 
schedule
 
=
 
computeSchedule();
 
      
schedule.seq
 
=
 
flattenSeq(schedule.seq);
 
      
currentSchedule
 
=
 
schedule;
 
      
renderMain(schedule);
 
    
});
 
 
    
document.getElementById('startCompare').addEventListener('click',
 
()
 
=>
 
{
 
      
if
 
(!processes.length)
 
return
 
alert('
‚ö†
 
Add
 
processes
 
first');
 
 
      
const
 
algoA
 
=
 
document.getElementById('algorithm').value;
 
      
const
 
algoB
 
=
 
document.getElementById('algorithmB').value;
 
 
      
if
 
(algoB
 
===
 
'none')
 
return
 
alert('
‚ö†
 
Choose
 
secondary
 
algorithm');
 
 
      
const
 
q
 
=
 
Number(document.getElementById('quantum').value)
 
||
 
1;
 
      
const
 
procCopy
 
=
 
processes.map(p
 
=>
 
({
 
...p
 
}));
 
 
      
const
 
sA
 
=
 
computeScheduleForList(procCopy,
 
algoA,
 
q);
 
      
const
 
sB
 
=
 
computeScheduleForList(procCopy,
 
algoB,
 
q);
 
 
      
sA.seq
 
=
 
flattenSeq(sA.seq);
 
      
sB.seq
 
=
 
flattenSeq(sB.seq);
 
 
      
renderMain(sA,
 
sB);
 
    
});
 
 
    
document.getElementById('pauseSim').addEventListener('click',
 
()
 
=>
 
{
 
      
anim.paused
 
=
 
!anim.paused;
 
      
document.getElementById('pauseSim').textContent
 
=
 
anim.paused
 
?
 
'
‚ñ∂
 
Resume'
 
:
 
'
‚è∏
 
Pause';
 
      
if
 
(!anim.paused)
 
runAnimStep();
 
    
});
 
 
    
document.getElementById('resetSim').addEventListener('click',
 
()
 
=>
 
{
 
      
resetVisuals();
 
    
});
 
 
    
function
 
resetVisuals()
 
{
 
      
timeline.innerHTML
 
=
 
'';
 
      
metricsTableDiv.innerHTML
 
=
 
'';
 
      
seqOut.textContent
 
=
 
'‚Äî';
 
      
document.getElementById('readyQ').textContent
 
=
 
'Ready:
 
‚Äî';
 
      
anim
 
=
 
{
 
        
events:
 
[],
 
        
idx:
 
0,
 
        
scale:
 
Number(document.getElementById('speed').value)
 
||
 
200,
 
        
playing:
 
false,
 
        
paused:
 
false,
 
        
playhead:
 
null,
 
        
minStart:
 
0,
 
        
maxEnd:
 
0,
 
        
total:
 
1
 
      
};
 
    
}
 
 
    
//
 
==================
 
AI
 
HELP
 
==================
 
    
document.getElementById('aiHelpBtn').addEventListener('click',
 
()
 
=>
 
{
 
      
document.getElementById('aiModal').style.display
 
=
 
'flex';
 
      
document.getElementById('aiAnswer').textContent
 
=
 
'';
 
    
});
 
 
    
document.getElementById('aiClose').addEventListener('click',
 
()
 
=>
 
{
 
      
document.getElementById('aiModal').style.display
 
=
 
'none';
 
    
});
 
 
    
document.getElementById('aiSend').addEventListener('click',
 
()
 
=>
 
{
 
      
const
 
q
 
=
 
document.getElementById('aiQuery').value.toLowerCase();
 
      
let
 
ans
 
=
 
'
üí≠
 
I
 
can
 
help
 
explain
 
algorithms
 
and
 
metrics.
 
Try:
 
"explain
 
sjf"
 
or
 
"how
 
is
 
waiting
 
time
 
computed".';
 
 
      
if
 
(q.includes('sjf'))
 
{
 
        
ans
 
=
 
'
üîÑ
 
SJF
 
(Shortest
 
Job
 
First)
 
schedules
 
processes
 
with
 
smallest
 
burst
 
time
 
first.
 
Non-preemptive
 
SJF
 
picks
 
the
 
shortest
 
available
 
job
 
when
 
CPU
 
becomes
 
free.
 
Preemptive
 
SJF
 
(SRTF)
 
can
 
interrupt
 
the
 
current
 
job
 
if
 
a
 
shorter
 
job
 
arrives.';
 
      
}
 
else
 
if
 
(q.includes('rr'))
 
{
 
        
ans
 
=
 
'
üîÑ
 
Round
 
Robin
 
uses
 
a
 
time
 
quantum
 
and
 
cycles
 
through
 
ready
 
processes
 
‚Äî
 
excellent
 
for
 
fairness
 
and
 
responsiveness.';
 
      
}
 
else
 
if
 
(q.includes('waiting'))
 
{
 
        
ans
 
=
 
'
‚è±
 
Waiting
 
Time
 
=
 
Turnaround
 
Time
 
-
 
Burst
 
Time.
 
Turnaround
 
Time
 
=
 
Completion
 
Time
 
-
 
Arrival
 
Time.';
 
      
}
 
else
 
if
 
(q.includes('priority'))
 
{
 
        
ans
 
=
 
'
‚≠ê
 
Priority
 
Scheduling
 
executes
 
processes
 
based
 
on
 
priority.
 
Lower
 
values
 
=
 
higher
 
priority.
 
Non-preemptive
 
finishes
 
current
 
job;
 
preemptive
 
can
 
interrupt.';
 
      
}
 
else
 
if
 
(q.includes('fcfs'))
 
{
 
        
ans
 
=
 
'
üìã
 
FCFS
 
(First
 
Come
 
First
 
Served)
 
is
 
the
 
simplest
 
algorithm.
 
Processes
 
execute
 
in
 
arrival
 
order.
 
Fair
 
but
 
can
 
cause
 
convoy
 
effect.';
 
      
}
 
else
 
if
 
(q.includes('metric'))
 
{
 
        
ans
 
=
 
'
üìä
 
Key
 
metrics:
 
Turnaround
 
Time
 
(CT
 
-
 
AT),
 
Waiting
 
Time
 
(TT
 
-
 
BT),
 
CPU
 
Utilization
 
(Total
 
Burst
 
/
 
Total
 
Time),
 
Throughput
 
(Processes
 
/
 
Total
 
Time).';
 
      
}
 
 
      
document.getElementById('aiAnswer').textContent
 
=
 
ans;
 
    
});
 
 
    
document.getElementById('aiQuery').addEventListener('keypress',
 
(e)
 
=>
 
{
 
      
if
 
(e.key
 
===
 
'Enter')
 
document.getElementById('aiSend').click();
 
    
});
 
 
    
//
 
==================
 
INIT
 
==================
 
    
(function
 
init()
 
{
 
      
processes
 
=
 
[
 
        
{
 
id:
 
1,
 
label:
 
'P1',
 
arrival:
 
0,
 
burst:
 
5,
 
priority:
 
2
 
},
 
        
{
 
id:
 
2,
 
label:
 
'P2',
 
arrival:
 
1,
 
burst:
 
3,
 
priority:
 
1
 
},
 
        
{
 
id:
 
3,
 
label:
 
'P3',
 
arrival:
 
3,
 
burst:
 
2,
 
priority:
 
3
 
}
 
      
];
 
      
nextId
 
=
 
4;
 
      
renderProcessTable();
 
    
})();
 
 
    
//
 
==================
 
EVENT
 
CLEANUP
 
==================
 
    
window.addEventListener('mousemove',
 
(e)
 
=>
 
{
 
      
if
 
(!tooltip.classList.contains('show'))
 
return;
 
    
});
 
 
    
window.addEventListener('scroll',
 
()
 
=>
 
tooltip.classList.remove('show'));
 
  
</script>
 
</body>
 
</html>
 
 
